# 实验四 Deadlock

## 1，死锁截图

![deadlock1](http://ww1.sinaimg.cn/large/a16d1d95jw1f9kwvpjh9fj208v07pmxi.jpg)

## 2，死锁产生的四个必要条件

#### 	2.1 互斥条件：一个资源每次只能被一个进程使用

#### 	2.2 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放

#### 	2.3 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺

#### 	2.4 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

## 3，对上述程序产生死锁的解释

	#### 主函数运行构造函数Deadlock()

 #### 执行t.start()，线程t被插入到调度队列里，当调度到t的时候，就跑run()里面的代码：b.methodB(a);

#### 接着执行while(count-->0);等待一段时间，然后执行a.methodA(b);

#### 当一个线程访问object的一个synchronized同步代码块或同步方法时，其他线程对object中所有其它synchronized同步代码块或同步方法的访问将被阻塞。所以每次只能执行b.methodB(a);和a.methodA(b);中的一个（互斥）

#### 如果a和b同时准备运行，就会发生死锁，都在等待对方运行结束释放资源（循环等待）













